### Introduction of zsh
**`zsh`**（全称 **Z Shell**）是终端（Terminal）中运行的一种**命令行解释器（Shell）**。

你可以把终端（Terminal）想象成一个“窗口”，而 `zsh` 就是坐在窗口里听你发号施令、并把指令传达给操作系统内核的“管家”。

以下是关于 `zsh` 最核心的几个概念，帮助你快速理解它：

### 1. 它是什么？

* **它是 Bash 的升级版：** 它是基于标准的 Bourne Shell (sh) 构建的，完全兼容 Bash（目前最通用的 Shell），但在功能、速度和定制化上做了大量的增强。
* **它是 macOS 的默认 Shell：** 从 macOS Catalina (10.15) 版本开始，苹果将默认的 Shell 从 Bash 换成了 Zsh。

---

### 2. 为什么大家都在用它？（核心优势）

相比于传统的 Bash，Zsh 之所以受到开发者和极客的喜爱，主要因为以下几点：

* **更智能的自动补全（Tab Completion）：**
在 Zsh 中按下 `Tab` 键，它不仅能补全文件名，还能补全命令参数。它会列出一个可选择的菜单，你可以通过方向键选择，非常直观。
* **强大的插件系统（Oh My Zsh）：**
这是 Zsh 最著名的生态系统。通过安装 **Oh My Zsh**，你可以一键获得几百种插件（比如自动跳转目录、Git 状态显示等）。
* **拼写纠正：**
如果你不小心把 `mkdir` 打成了 `mdkir`，Zsh 会智能地问你：“你是指 mkdir 吗？”并尝试帮你修正。
* **高度可定制的主题：**
Zsh 的提示符（Prompt）非常漂亮，可以显示当前路径、Git 分支、电量、执行时间等信息，并且支持各种配色方案。

---

### 3. 如何确认你是否在使用 zsh？

打开你的终端，输入以下命令并回车：

```bash
echo $SHELL
```

* 如果输出 `/bin/zsh`，说明你当前正在使用 **zsh**。
* 如果输出 `/bin/bash`，说明你正在使用 **bash**。

---

### 4. Zsh 与 Bash 的简单对比

| 特性 | Bash | Zsh |
| --- | --- | --- |
| **默认系统** | 大多数 Linux 发行版 | macOS (最新版), Kali Linux |
| **自动补全** | 基础 | **非常强大** (支持菜单选择) |
| **配置难度** | 较低，但功能朴素 | 配合 Oh My Zsh 后**极易配置**且功能强大 |
| **兼容性** | 极高 (行业标准) | 兼容 Bash 95% 以上的语法 |

---

**`zsh` 就是一个更现代、更强大、更漂亮、更懂你的命令行工具。** 如果你经常需要使用终端，从 Bash 切换到 Zsh 会极大地提升你的工作效率。

### Vim与zsh之间的关系
如果说 **`zsh`** 是坐在窗口指挥系统的 **“管家”**，那么 **`vim`** 就是管家手里那本 **“超级笔记本”**。

**`vim`**（全称 **Vi IMproved**）是在终端中运行的一个**纯文本编辑器**。它不是用来发号施令的（那是 Shell 的工作），而是专门用来**写代码、改配置文件、写文档**的。

以下是关于 `vim` 的核心概念，帮助你快速理解它：

### 1. 它是什么？

* **它是终端里的 Word/记事本：** 当你在没有图形界面（鼠标点不了）的服务器上，或者想在写代码时不碰鼠标，你就需要用 `vim` 来编辑文件。
* **它是“鼠标杀手”：** `vim` 的设计哲学是**让你的双手永远不离开键盘的主区域**。通过各种快捷键组合，你可以比用鼠标极快地移动光标、复制粘贴和修改文本。

---

### 2. 为什么它这么出名（且让人头秃）？

Vim 最让新手困惑，也最让老手着迷的地方，在于它有 **“模式”**（Modes）的概念。

打开 `vim` 时，你不能直接打字！这和我们习惯的记事本完全不同：

* **普通模式 (Normal Mode)** —— **默认模式**。
* 在这里，按键盘不是打字，而是**移动光标**或**发出指令**。
* 比如：按 `dd` 删除一行，按 `yy` 复制一行，按 `p` 粘贴。


* **插入模式 (Insert Mode)** —— **打字模式**。
* 你需要按一下 `i` 键，才能进入这个模式。这时你按键盘，屏幕上才会出现文字，就像普通的记事本一样。
* 按 `Esc` 键退出，回到普通模式。


* **命令模式 (Command Mode)** —— **存盘退出模式**。
* 在普通模式下按 `:` (冒号)，底部会出现一个输入框。
* 输入 `w` 保存，输入 `q` 退出。



> **经典笑话：** “我已经用了 Vim 两年了，主要原因是……我一直不知道怎么退出来。” (答案是：按 `Esc`，然后输入 `:wq` 回车)。

---

### 3. Zsh 和 Vim 的关系

它们是**搭档**，经常一起出现，但分工明确：

| 特性 | Zsh (Shell) | Vim (Editor) |
| --- | --- | --- |
| **角色** | **指挥官** | **记录员** |
| **主要功能** | 执行命令、管理文件、运行程序 | 编辑文件内容、写代码 |
| **操作对象** | 操作系统 (Filesystem, Processes) | 文本内容 (Text, Code) |
| **典型场景** | "帮我把这个文件移动到那里" | "帮我打开这个文件，修改第3行" |
| **命令示例** | `ls`, `cd`, `git commit` | `i` (插入), `:w` (保存), `dd` (删除) |

**场景举例：**
你用 **Zsh** 命令 `cd` 进入一个文件夹，然后用 **Zsh** 命令 `touch index.html` 创建一个文件。
接着，你用 **Zsh** 命令 `vim index.html` 呼叫 **Vim** 打开这个文件。
**（此时控制权交给 Vim）** 你在 Vim 里写了一段 HTML 代码，保存退出。
**（控制权回到 Zsh）** 你继续用 Zsh 操作其他事情。

---
**`vim` 是一个在终端里运行的、极度崇尚效率的文本编辑器。** 它的学习曲线很陡峭（像一面墙），但一旦学会，你的编程和编辑速度会快得惊人。

### Introduction of Node.js
下面我按**“从本质 → 架构 → 运行机制 → 与前后端关系 → 典型使用场景 → 常见误区”**的顺序，**系统而深入**地给你讲清楚 **Node.js**。读完你应该能理解：**Node.js 到底是什么、为什么快、适合什么、不适合什么**。

---

## 一、Node.js 本质是什么？（一句话版本）

> **Node.js 是一个让 JavaScript 可以在“浏览器之外”运行的运行时环境（runtime），主要用于构建高并发、I/O 密集型服务器程序。**

⚠️ 注意三个关键词：

* **不是语言**（语言是 JavaScript）
* **不是框架**（如 Express、Nest）
* **是运行时环境**

---

## 二、为什么会有 Node.js？（历史背景）

在 Node.js 出现之前：

* JavaScript 只能在 **浏览器** 里跑
* 后端常用：

  * Java（Servlet、Spring）
  * PHP
  * Python（Django）
* 问题：

  * 高并发连接（聊天室、长轮询）效率低
  * 线程/进程切换开销大

### Node.js 的核心创新（2009，Ryan Dahl）

> **用事件驱动 + 非阻塞 I/O + 单线程模型来解决高并发问题**

---

## 三、Node.js 的核心架构（非常重要）

### 1️⃣ V8 引擎

Node.js 底层使用：

* **Google Chrome 的 V8 引擎**
* 把 JavaScript 编译成 **机器码**
* 非常快（不是解释执行）

---

### 2️⃣ 单线程 ≠ 只能干一件事（关键误区）

Node.js 的 JS 执行是 **单线程**，但：

* I/O 操作（网络、文件、数据库）
  → **交给系统线程池**
* JS 只负责：

  * 发起任务
  * 处理回调

👉 这就是 **“非阻塞”** 的本质。

---

### 3️⃣ Event Loop（事件循环）

这是 Node.js 的灵魂。

#### 事件循环的核心思想：

```text
while (有任务) {
  取一个任务
  执行
}
```

但任务分不同队列：

| 队列            | 举例           |
| ------------- | ------------ |
| timers        | setTimeout   |
| I/O callbacks | 网络请求         |
| poll          | 主要 I/O       |
| check         | setImmediate |
| microtask     | Promise.then |

👉 **Promise 的优先级高于 setTimeout**

---

## 四、一个简单例子理解非阻塞

### ❌ 阻塞模型（传统）

```js
const data = readFileSync("big.txt");
console.log(data);
```

👉 整个服务器在等文件读完

---

### ✅ Node.js 非阻塞模型

```js
fs.readFile("big.txt", (err, data) => {
  console.log(data);
});
console.log("I run first");
```

👉 Node.js 不等 I/O，继续处理其他请求

---

## 五、Node.js 在“前后端”中的位置

### 前端（浏览器）

* DOM
* window
* alert

### Node.js（服务器）

* 没有 DOM
* 有：

  * fs（文件系统）
  * http（服务器）
  * net（TCP）
  * process（进程）

```js
const http = require("http");

http.createServer((req, res) => {
  res.end("Hello Node");
}).listen(3000);
```

---

## 六、Node.js 的生态系统：npm

### npm 是什么？

> **全球最大的开源包管理系统**

* 超过百万个包
* 一行命令安装：

```bash
npm install express
```

---

### 常见 Node 框架

| 框架      | 用途             |
| ------- | -------------- |
| Express | 轻量 Web 服务      |
| Koa     | 更现代            |
| NestJS  | 企业级（类似 Spring） |
| Fastify | 高性能            |

---

## 七、Node.js 最适合做什么？

### ✅ 非常适合

| 场景         | 原因        |
| ---------- | --------- |
| API 服务     | 高并发       |
| 实时聊天       | WebSocket |
| BFF 层      | 前后端同语言    |
| 微服务        | 启动快       |
| Serverless | 冷启动快      |

---

### ❌ 不适合

| 场景      | 原因           |
| ------- | ------------ |
| CPU 密集型 | 单线程          |
| 科学计算    | Python / C++ |
| 图像处理    | GPU 更合适      |

👉 **CPU 密集任务会阻塞 event loop**

---

## 八、Node.js 是如何处理并发的？（教授级理解）

### 传统服务器（多线程）

```text
1 request = 1 thread
```

缺点：

* 线程切换慢
* 内存消耗大

---

### Node.js（事件驱动）

```text
1 process
1 JS thread
N concurrent requests
```

**关键：**

* I/O 等待时间不占用线程
* 一个 Node 进程能处理上万连接

---

## 九、Node.js 的常见误区（一定要避开）

### ❌ 误区 1：Node.js 很慢

→ 错
Node.js 在 I/O 场景非常快

---

### ❌ 误区 2：Node.js 不安全

→ 错
安全与否取决于：

* 代码
* 框架
* 运维

---

### ❌ 误区 3：Node.js 不适合大项目

→ 错
Netflix、PayPal、Uber 大量使用

---

## 十、你应该如何学习 Node.js？（路线图）

### Step 1：JS 基础

* 闭包
* Promise
* async/await

### Step 2：Node 核心模块

* fs
* http
* path
* events

### Step 3：Web 框架

* Express / NestJS

### Step 4：工程化

* npm / yarn
* ESLint
* Docker

---
> **Node.js 不是为了“算得快”，而是为了“等得少”。**

